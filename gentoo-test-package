#!/usr/bin/env python

import logging

log = logging.getLogger("test-package")
options = None


def massage_string(string):
    """Return a string."""

    import sys

    if sys.version_info[0] < 3:
        return string
    else:
        return string.decode("UTF-8")


class Docker:

    def __init__(self, local_portage, update=True, use=[], threads=1,
                 gcc_version=None):
        """Create a new container.

        local_portage is the path to the local portage repository. The
        update argument specifies whether to update the container. The threads
        variable specifies how many threads emerge should use.
        """

        import re
        import subprocess

        docker_container = "gentoo/stage3-amd64-nomultilib"
        docker_args = ["docker", "pull", docker_container]
        docker = subprocess.Popen(docker_args)
        docker.wait()
        docker_args = [
            "docker", "run", "--detach", "--tty",
            "--cap-add", "SYS_ADMIN",
            "--device", "/dev/fuse",
            "--workdir", "/root",
            "--volume=%s:/usr/portage" % (local_portage),
            "--volume=/usr/portage/distfiles:/usr/portage/distfiles",
            docker_container]
        log.info("creating docker container with: %s" %
                 (" ".join(docker_args)))
        docker = subprocess.Popen(docker_args, stdout=subprocess.PIPE)
        docker.wait()
        if docker.returncode != 0:
            raise Exception("failure creating docker container")
        lines = docker.stdout.readlines()
        if len(lines) > 1:
            raise Exception("more output than expected")
        self.cid = massage_string(lines[0]).strip()
        log.info("container id %s" % (self.cid))

        # Disable the usersandbox feature, it's not working well inside a
        # docker container.
        self.execute("echo FEATURES=\\\"-sandbox -usersandbox\\\" " +
                     ">> /etc/portage/make.conf")
        self.execute(("echo MAKEOPTS=\\\"-j%d\\\" " % (threads)) +
                     ">> /etc/portage/make.conf")

        self.execute(
            "echo \"%s\" ~amd64 >> /etc/portage/package.accept_keywords" %
            (options.ATOM))
        if len(use) > 0:
            self.execute("echo %s %s >> /etc/portage/package.use/testbuild" %
                         (options.ATOM, " ".join(use)))

        # Update.
        if update:
            self.execute("emerge --update --deep --newuse @world")

        self.execute("emerge app-portage/gentoolkit")

        # Set gcc version.
        if gcc_version:
            self.execute(("echo =sys-devel/gcc-%s ** >> " % gcc_version) +
                         "/etc/portage/package.accept_keywords")
            self.execute("emerge --verbose sys-devel/gcc")
            gcc = re.sub("-r[0-9]+$", "", gcc_version)
            self.execute("gcc-config $(gcc-config --list-profiles | " +
                         ("grep %s | " % gcc) +
                         "sed -e 's:^.*\[\([0-9]\+\)\].*:\\1:')")
            self.execute("emerge --oneshot sys-devel/libtool")

        self.execute("cat /etc/portage/package.accept_keywords")
        self.execute("if [[ -f /etc/portage/package.use/testbuild ]]; then " +
                     "cat /etc/portage/package.use/testbuild; fi")
        self.execute("emerge --info")

    def reader(self, proc, stream, name):
        """Read from a subprocess stream."""

        global log
        global log_ch

        while True:
            out = stream.readline()
            if out == "" and proc.poll() is not None:
                break
            log.info("%s %s: %s" % (self.cid[:6], name, out.rstrip()))
            log_ch.flush()

    def execute(self, cmd):
        """Execute command in container.

        cmd is a string which is executed within a bash shell.
        """

        import os
        import subprocess
        import sys

        global log

        log.info("%s %s" % (self.cid[:6], cmd))
        docker_cmd = ["docker", "exec", "--interactive"]
        docker_cmd += [self.cid, "/bin/bash"]
        docker = subprocess.Popen(docker_cmd, stdout=subprocess.PIPE,
                                  stderr=subprocess.PIPE,
                                  stdin=subprocess.PIPE,
                                  universal_newlines=True)
        docker.stdin.write(cmd + "\n")
        docker.stdin.close()
        stdout_reader = os.fork()
        if stdout_reader == 0:
            self.reader(docker, docker.stdout, "stdout")
            sys.exit(0)
        stderr_reader = os.fork()
        if stderr_reader == 0:
            self.reader(docker, docker.stderr, "stderr")
            sys.exit(0)
        os.waitid(os.P_PID, stdout_reader, os.WEXITED)
        os.waitid(os.P_PID, stderr_reader, os.WEXITED)
        docker.wait()
        if docker.returncode != 0:
            log.error("running in container %s" % (str(self.cid)))
            raise Exception("failed command \"%s\"" % (cmd))

    def shell(self):
        """Run an interactive shell in container."""

        import subprocess

        global log

        log.info("running interactive shell in container")
        docker = subprocess.Popen(["docker", "exec", "--tty", "--interactive",
                                  self.cid, "/bin/bash"])
        docker.wait()


def parse_commandline():
    """Parse the command line."""

    import argparse

    global options

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "ATOM",
        help="The package atom to test")
    parser.add_argument(
        "--manual",
        help="Install package manually",
        default=False,
        action="store_true")
    parser.add_argument(
        "--portage-dir",
        help="The local portage directory",
        required=True)
    parser.add_argument(
        "--no-update",
        help="Do not update container before installing ATOM",
        default=False,
        action="store_true")
    parser.add_argument(
        "--threads",
        metavar="N",
        help="Use N threads to build packages",
        default=1,
        type=int)
    parser.add_argument(
        "--use",
        help="The use flags for the ATOM",
        default=[],
        nargs="+")
    parser.add_argument(
        "--gcc-version",
        metavar="VER",
        help="Use gcc version VER")
    options = parser.parse_args()


def main():
    """The main function."""

    import os.path

    global log
    global log_ch
    global options

    log.setLevel(logging.DEBUG)

    log_ch = logging.StreamHandler()
    log_ch.setLevel(logging.INFO)
    log_ch.setFormatter(logging.Formatter("%(asctime)s - %(message)s"))
    log.addHandler(log_ch)

    fh = logging.FileHandler("tester.log", "a")
    fh.setLevel(logging.INFO)
    fh.setFormatter(logging.Formatter("%(asctime)s - %(message)s"))
    log.addHandler(fh)

    parse_commandline()

    log.info("creating container")
    container = Docker(os.path.abspath(options.portage_dir),
                       update=(not options.no_update),
                       use=options.use, threads=options.threads,
                       gcc_version=options.gcc_version)

    log.info("created container " + container.cid)
    if options.manual:
        container.shell()
    else:
        container.execute("echo emerge --ask --autounmask-write --verbose " +
                          options.ATOM +
                          " >> ~/.bash_history")
        try:
            container.execute("emerge --autounmask-write --verbose " +
                              options.ATOM)
        except Exception:
            log.warn("ignoring failure of command")
        container.execute("etc-update --automode -5")
        try:
            container.execute("emerge --verbose " + options.ATOM)
        except Exception:
            log.warn("ignoring failure of command")
        container.shell()

if __name__ == "__main__":
    main()
else:
    raise Exception("can not be imported")
