#!/usr/bin/env python

import logging

log = logging.getLogger("test-package")
options = None


def massage_string(string):
    """Return a string."""

    import sys

    if sys.version_info[0] < 3:
        return string
    else:
        return string.decode("UTF-8")


class Docker:

    def __init__(self, local_portage, update=True, threads=1,
                 gcc_version=None):
        """Create a new container.

        local_portage is the path to the local portage repository. The
        update argument specifies whether to update the container. The threads
        variable specifies how many threads emerge should use.
        """

        import subprocess

        docker_container = "gentoo/stage3-amd64-nomultilib"
        docker_args = ["docker", "pull", docker_container]
        docker = subprocess.Popen(docker_args)
        docker.wait()
        docker_args = [
            "docker", "run", "--detach", "--tty",
            "--cap-add", "SYS_ADMIN",
            "--device", "/dev/fuse",
            "--workdir", "/root",
            "--volume=%s:/usr/portage" % (local_portage),
            "--volume=/usr/portage/distfiles:/usr/portage/distfiles",
            docker_container]
        log.info("creating docker container with: %s" %
                 (" ".join(docker_args)))
        docker = subprocess.Popen(docker_args, stdout=subprocess.PIPE)
        docker.wait()
        if docker.returncode != 0:
            raise Exception("failure creating docker container")
        lines = docker.stdout.readlines()
        if len(lines) > 1:
            raise Exception("more output than expected")
        self.cid = massage_string(lines[0]).strip()

        # Update bash environment.
        self.execute("echo HISTORY=1000 >> /root/.bashrc")

        # Disable the usersandbox feature, it's not working well inside a
        # docker container.
        self.execute("echo FEATURES=\\\"-sandbox -usersandbox\\\" " +
                     ">> /etc/portage/make.conf")
        self.execute(("echo MAKEOPTS=\\\"-j%d\\\" " % (threads)) +
                     ">> /etc/portage/make.conf")
        self.execute("emerge --info")
        # Update.
        if update:
            self.execute("emerge --update --deep --newuse @world")

        # Set gcc version.
        if gcc_version:
            self.execute(("echo =sys-devel/gcc-%s ** >> " % gcc_version) +
                         "/etc/portage/package.accept_keywords")
            self.execute("emerge --verbose sys-devel/gcc")
            self.execute("gcc-config $(gcc-config --list-profiles | " +
                         ("grep ${%s/%%-r*/} |" % gcc_version) +
                         "sed -e 's:^.*\[\([0-9]\+\)\].*:\\1:')")
            self.execute("emerge --oneshot sys-devel/libtool")

    def execute(self, cmd, interactive=False):
        """Execute command in container.

        cmd is a string which is executed within a bash shell.
        """

        import subprocess

        global log

        log.info("running \"%s\" in container" % (cmd))
        docker_cmd = ["docker", "exec"]
        if interactive:
            docker_cmd += ["--tty", "--interactive"]
        docker_cmd += [self.cid, "/bin/bash", "-c", cmd]
        docker = subprocess.Popen(docker_cmd)
        docker.wait()
        if docker.returncode != 0:
            log.error("running in container %s" % (str(self.cid)))
            raise Exception("failed command \"%s\"" % (cmd))

    def shell(self):
        """Run an interactive shell in container."""

        import subprocess

        global log

        log.info("running interactive shell in container")
        docker = subprocess.Popen(["docker", "exec", "--tty", "--interactive",
                                  self.cid, "/bin/bash"])
        docker.wait()


def parse_commandline():
    """Parse the command line."""

    import argparse

    global options

    parser = argparse.ArgumentParser()
    parser.add_argument(
        "ATOM",
        help="The package atom to test")
    parser.add_argument(
        "--portage-dir",
        help="The local portage directory",
        required=True)
    parser.add_argument(
        "--no-update",
        help="Do not update container before installing ATOM",
        default=False,
        action="store_true")
    parser.add_argument(
        "--threads",
        metavar="N",
        help="Use N threads to build packages",
        default=1,
        type=int)
    parser.add_argument(
        "--use",
        help="The use flags for the ATOM",
        nargs="+")
    parser.add_argument(
        "--gcc-version",
        metavar="VER",
        help="Use gcc version VER")
    options = parser.parse_args()


def main():
    """The main function."""

    import os.path

    global log
    global options

    log.setLevel(logging.DEBUG)
    ch = logging.StreamHandler()
    ch.setLevel(logging.INFO)
    ch.setFormatter(logging.Formatter("%(asctime)s - %(message)s"))
    log.addHandler(ch)

    log.info("starting")

    parse_commandline()

    log.info("creating container")
    container = Docker(os.path.abspath(options.portage_dir),
                       update=(not options.no_update),
                       threads=options.threads,
                       gcc_version=options.gcc_version)

    log.info("created container " + container.cid)
    container.execute(
        "echo \"%s\" ~amd64 >> /etc/portage/package.accept_keywords" %
        (options.ATOM))
    container.execute("cat /etc/portage/package.accept_keywords")
    if not (options.use is None) and len(options.use) > 0:
        container.execute("echo %s %s >> /etc/portage/package.use/testbuild" %
                          (options.ATOM, " ".join(options.use)))
    container.execute("echo emerge --ask --verbose %s >> ~/.bash_history" %
                      (options.ATOM))
    try:
        container.execute("emerge --ask --verbose %s" % (options.ATOM),
                          interactive=True)
    except Exception:
        log.warn("ignoring failure of command")
    container.shell()

if __name__ == "__main__":
    main()
else:
    raise Exception("can not be imported")
